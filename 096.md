0xbepresent

medium

# Claimable amount could be sent to the approved address instead the provision/position owner

## Summary

If the Provision ER721 has an ```approved``` address, the amount available to claim in [ClaimFacet.sol::claim()](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L25) are sent to the approved address instead the provision owner. 

## Vulnerability Detail

A [Provision ERC721 is minted](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L91) to the offer signer when an offer is accepted, then the provision owner can [claim](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L25) the interests once the Collateral NFT was liquidated or the borrow was repayed by the borrower.

The problem is that if the Provision/Position owner assigns an approved address via the [approve()](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/SupplyPositionLogic/NFTUtils.sol#L115) function, the approved address will receive the interests generated by the lend. The approved address must be only able to transfer the ERC721 but he should not receive the interesets.

## Impact

The ```approved``` address acts on behalf the owner, so the operator (approved address) has the ability to transfer the ERC721. However the ```offer owner``` is the address who should receive the interests.

I created a test in ```ClaimExternal.t.sol``` where the claimable amount is paid to the approved address instead the owner.

```solidity
import {SupplyPositionFacet} from "../../src/SupplyPositionFacet.sol";

function testClaimOnLiquidatedLoanAsApproved() public {
    // Claimable amount is paid to the approved address instead the owner
    // 1. Set the loan and get the provision NFT
    // 2. Signer approves the address(1337) to transfer the NFT
    // 3. Address(1337) calls the claim() function
    // 4. The claim amount is going to the approved address instead the owner/signer.
    //
    // 1. Set the loan and get the provision NFT
    //
    Loan memory loan = getLoan();

    loan.payment.liquidated = true;
    loan.payment.paid = 1 ether;

    store(loan, 1);
    Provision memory provision = getProvision();
    uint256 tokenId = mintPosition(signer, provision);

    SupplyPositionFacet supplyPositionFacet = new SupplyPositionFacet();
    assertEq(supplyPositionFacet.balanceOf(signer), 1);

    getFlooz(address(kairos), money);
    //
    // 2. Signer approves the address(1337) to transfer the NFT
    //
    vm.prank(signer);
    supplyPositionFacet.approve(address(1337), tokenId);
    //
    // 3. Address(1337) calls the claim() function
    //
    vm.prank(address(1337));
    kairos.claim(oneInArray);
    //
    // 4. The claim amount is going to the approved address instead the owner/signer.
    //
    assertEq(money.balanceOf(address(1337)), 1 ether);
    assertEq(money.balanceOf(address(signer)), 0);
}
```

## Code Snippet

The [claim()](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L25-L53) function check if the ```msg.sender``` is the approved or the owner via ```_isApprovedOrOwner()```. The interests or liquidated amount will be send the money via [sendShareOfSaleAsSupplier()](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L43) or [sendInterests()](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L48) functions to the ```msg.sender``` regardless if the caller is the owner or the approved address.

```solidity
function claim(uint256[] calldata positionIds) external returns (uint256 sent) {
    Protocol storage proto = protocolStorage();
    SupplyPosition storage sp = supplyPositionStorage();
    Loan storage loan;
    Provision storage provision;
    uint256 loanId;
    uint256 sentTemp;


    for (uint256 i = 0; i < positionIds.length; i++) {
        if (!_isApprovedOrOwner(msg.sender, positionIds[i])) {
            revert ERC721CallerIsNotOwnerNorApproved();
        }
        _burn(positionIds[i]);
        provision = sp.provision[positionIds[i]];
        loanId = provision.loanId;
        loan = proto.loan[loanId];


        if (loan.payment.liquidated) {
            sentTemp = sendShareOfSaleAsSupplier(loan, provision);
        } else {
            if (loan.payment.paid == 0) {
                revert LoanNotRepaidOrLiquidatedYet(loanId);
            }
            sentTemp = sendInterests(loan, provision);
        }
        emit Claim(msg.sender, sentTemp, loanId);
        sent += sentTemp;
    }
}
```

## Tool used

Vscode

## Recommendation

Send the claimable amount to the provision owner instead of the approved address if an approved address was set.